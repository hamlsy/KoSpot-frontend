KoSpot: WebSocket 기반 실시간 멀티플레이어 위치 추론 게임 시스템

요약 (Abstract)

본 논문은 한국의 관광지를 로드뷰와 포토를 통해 재미있게 위치를 맞추는 게임 서비스인 KoSpot의 개발 과정과 기술적 구현 방법을 제시한다. KoSpot은 사용자들이 구글 스트리트뷰와 유사한 로드뷰 환경에서 주어진 위치의 좌표를 추론하는 게임으로, 싱글 플레이어 모드와 멀티플레이어 모드를 제공한다.

본 연구에서는 실시간 멀티플레이어 게임을 구현하기 위해 WebSocket 기반의 실시간 통신 시스템을 구축하였다. STOMP 프로토콜을 활용하여 게임 상태 동기화, 플레이어 간 실시간 상호작용, 게임 타이머 동기화 등의 기능을 구현하였다. 또한 Redis를 활용한 게임 상태 관리 시스템을 설계하여 다수의 동시 접속자를 효율적으로 처리할 수 있도록 하였다.

시스템 아키텍처는 Domain-Driven Design(DDD) 원칙을 적용하여 계층형 구조로 설계하였으며, 백엔드는 Spring Boot 기반의 4계층 아키텍처로, 프론트엔드는 Vue 3 Composition API 기반의 Feature-based 모듈 구조로 구성하였다. 배포는 Docker 컨테이너화와 AWS 인프라를 활용하여 확장 가능하고 안정적인 서비스를 제공하도록 구성하였다.

사용자 인터페이스는 기능성과 미적 균형을 추구하는 디자인 원칙을 적용하여 직관적이고 몰입감 있는 사용자 경험을 제공하도록 설계하였다. 실제 서비스 운영 결과, 사용자들은 로드뷰를 통한 위치 추론의 재미와 지리 학습 효과에 대해 긍정적인 피드백을 제공하였으며, 멀티플레이어 기능과 랭킹 시스템이 게임 지속성을 높이는 데 기여함을 확인하였다. 다만 지리 관심도가 낮은 사용자들의 지속적 플레이 어려움과 난이도 조절의 필요성 등의 개선점도 발견되었다.

목차

1. 서론
   1.1 연구 배경 및 동기
   1.2 연구 목적
   1.3 논문 구성

2. 서비스 개요
   2.1 서비스 소개 및 기획 의도
   2.2 타겟 사용자 및 기대 효과

3. 시스템 설계
   3.1 전체 아키텍처 개요
   3.2 백엔드 아키텍처
   3.3 프론트엔드 아키텍처
   3.4 데이터베이스 설계

4. 주요 기능 구현
   4.1 싱글 플레이어 게임
   4.2 멀티플레이어 게임
   4.3 실시간 통신 구현
   4.4 랭킹 및 포인트 시스템

5. 사용자 인터페이스 및 경험
   5.1 UI/UX 디자인 원칙
   5.2 주요 화면 구성 및 플레이 플로우
   5.3 플레이 사진 및 시나리오별 기획 의도

6. 기술 스택 및 배포
   6.1 사용 기술 스택
   6.2 배포 시스템

7. 성능 최적화 및 개선
   7.1 백엔드 최적화
   7.2 프론트엔드 최적화
   7.3 성능 개선 결과

8. 사용자 피드백 및 결론
   8.1 사용자 피드백 분석
   8.2 향후 개선 방향
   8.3 결론

참고문헌

그림 목차

그림 3-1. KoSpot 시스템 전체 아키텍처
그림 3-2. 계층형 아키텍처 구조
그림 3-3. 프론트엔드 아키텍처 구조
그림 3-4. ERD (Entity Relationship Diagram)
그림 4-1. 싱글 플레이어 게임 플로우
그림 4-2. 멀티플레이어 게임 플로우
그림 4-3. WebSocket 채널 구조
그림 5-1. 메인 페이지 화면
그림 5-2. 로드뷰 게임 진행 화면
그림 5-3. 멀티플레이어 로비 화면
그림 5-4. 게임 진행 화면
그림 6-1. 배포 아키텍처
그림 6-2. CI/CD 파이프라인

표 목차

표 6-1. 사용 기술 스택
표 6-2. 주요 라이브러리 및 의존성
표 7-1. 성능 최적화 결과
표 8-1. 사용자 피드백 요약

1. 서론

1.1 연구 배경 및 동기

최근 게임화(Gamification)를 통한 교육 효과에 대한 관심이 높아지고 있으며, 특히 지리 교육 분야에서 인터랙티브한 학습 방법의 필요성이 대두되고 있다. 기존의 지리 학습은 주로 지도와 교과서를 통한 이론 중심의 학습이었으나, 실제 공간에 대한 이해와 직관적 학습을 제공하는 방법이 부족하였다.

한국은 다양한 관광지와 랜드마크를 보유하고 있으나, 국민들이 이러한 장소들에 대한 지리적 인식이 부족한 실정이다. 특히 젊은 세대들은 자신이 거주하는 지역 외의 다른 지역에 대한 지리적 지식이 상대적으로 부족한 편이다.

이러한 배경에서 본 연구는 로드뷰(Street View) 기술을 활용하여 사용자들이 실제 환경을 탐색하면서 위치를 추론하는 게임을 개발하고자 하였다. 게임의 재미 요소와 학습 효과를 결합하여, 사용자들이 자연스럽게 한국의 지리를 학습할 수 있는 서비스를 제공하는 것이 본 연구의 목적이다.

또한 단순한 싱글 플레이어 게임을 넘어서, 친구들과 함께 플레이할 수 있는 멀티플레이어 기능을 제공함으로써 사회적 상호작용을 통한 학습 동기 부여와 게임의 지속성을 높이고자 하였다.

1.2 연구 목적

본 연구의 주요 목적은 다음과 같다:

1. 실시간 멀티플레이어 게임 시스템 구축: WebSocket 기반의 실시간 통신을 통해 여러 사용자가 동시에 게임을 플레이할 수 있는 시스템을 구현한다.

2. 게임 상태 동기화 메커니즘 개발: Redis를 활용하여 게임 방의 상태, 플레이어 정보, 게임 진행 상황 등을 효율적으로 관리하고 동기화한다.

3. 확장 가능한 아키텍처 설계: Domain-Driven Design 원칙을 적용하여 유지보수성과 확장성을 고려한 시스템 아키텍처를 설계한다.

4. 안정적인 서비스 배포: Docker와 AWS를 활용하여 확장 가능하고 안정적인 클라우드 인프라를 구축한다.

5. 사용자 경험 개선: 실제 사용자 피드백을 수집하고 분석하여 서비스 개선 방향을 도출한다.

1.3 논문 구성

본 논문은 다음과 같이 구성된다. 2장에서는 서비스 소개 및 기획 의도를 제시한다. 3장에서는 백엔드와 프론트엔드를 포함한 전체 시스템 아키텍처를 설명한다. 4장에서는 주요 기능의 구현 방법을 백엔드와 프론트엔드 관점에서 통합하여 설명한다. 5장에서는 사용자 인터페이스 및 경험 설계를 다룬다. 6장에서는 사용 기술 스택과 배포 시스템을 소개한다. 7장에서는 성능 최적화 방법과 결과를 제시한다. 8장에서는 사용자 피드백 분석과 향후 개선 방향, 결론을 제시한다.

2. 서비스 개요

2.1 서비스 소개 및 기획 의도

KoSpot은 한국의 관광지를 로드뷰와 포토를 통해 재미있게 위치를 맞추는 게임 서비스이다. 사용자들이 실제 환경을 탐색하면서 위치를 추론하는 과정을 통해 자연스럽게 지리 지식을 습득할 수 있도록 설계되었다.

핵심 가치 제안

KoSpot의 핵심 가치는 "게임을 통한 지리 학습"이다. 기존의 지리 학습이 지도와 교과서 중심의 이론적 접근이었다면, KoSpot은 실제 환경을 탐색하고 상호작용하는 과정을 통해 직관적이고 몰입감 있는 학습 경험을 제공한다.

게임 모드의 차별점

- 로드뷰 모드: 구글 스트리트뷰와 유사한 360도 로드뷰 환경에서 실제 거리를 둘러보며 위치를 추론한다. 사용자는 마치 그 장소에 직접 있는 것처럼 주변 환경을 탐색할 수 있어 높은 몰입감을 제공한다.

- 포토 모드: 관광지 사진을 통해 지역을 맞히는 모드로, 시각적 단서를 활용한 추론 능력을 요구한다. 로드뷰와는 다른 방식의 지리 학습 경험을 제공한다.

기획 의도

1. 로드뷰 게임을 선택한 이유: 실제 환경을 탐색하는 과정은 단순히 좌표를 맞추는 것 이상의 몰입감을 제공한다. 사용자는 건물, 풍경, 간판 등 다양한 단서를 통해 위치를 추론하며, 이 과정에서 자연스럽게 해당 지역의 특성을 학습하게 된다.

2. 멀티플레이어 기능의 필요성: 단순한 싱글 플레이어 게임을 넘어서 친구들과 함께 플레이할 수 있는 멀티플레이어 기능을 제공함으로써 사회적 상호작용을 통한 학습 동기 부여와 게임의 지속성을 높이고자 하였다. 경쟁 요소와 협력 요소를 결합하여 더욱 재미있는 경험을 제공한다.

3. 랭킹 시스템의 역할: 티어 시스템과 랭크 점수를 통해 사용자의 성장을 시각화하고, 경쟁 요소를 도입하여 지속적인 플레이 동기를 부여한다. 8단계의 티어 시스템(BRONZE부터 CHALLENGER까지)은 사용자가 목표를 설정하고 달성하는 과정에서 성취감을 느낄 수 있도록 설계되었다.

2.2 타겟 사용자 및 기대 효과

타겟 사용자

1. 지리 학습에 관심 있는 사용자: 한국의 지리를 학습하고 싶은 사용자들에게 게임을 통한 재미있는 학습 경험을 제공한다.

2. 게임을 즐기는 사용자: 게임의 재미 요소를 즐기면서 자연스럽게 지리 지식을 습득할 수 있다.

3. 친구들과 함께 플레이하고 싶은 사용자: 멀티플레이어 기능을 통해 친구들과 함께 게임을 즐기며 사회적 상호작용을 경험할 수 있다.

기대 효과

1. 지리 학습 효과: 로드뷰와 포토를 통한 실제 환경 탐색은 이론적 학습보다 직관적이고 오래 기억에 남는 학습 경험을 제공한다.

2. 게임 지속성: 멀티플레이어 기능과 랭킹 시스템을 통해 사용자의 지속적인 참여를 유도한다.

3. 사회적 상호작용: 친구들과 함께 플레이하며 협력하고 경쟁하는 과정에서 학습 동기가 부여된다.

3. 시스템 설계

3.1 전체 아키텍처 개요

KoSpot 시스템은 클라이언트-서버 아키텍처를 기반으로 하며, 웹 브라우저를 통한 접근을 지원한다. 클라이언트는 Vue 3 기반의 프론트엔드 애플리케이션으로 구성되며, RESTful API를 통해 서버와 통신하고 실시간 기능은 WebSocket을 통해 구현된다.

서버 측은 Spring Boot 기반의 백엔드 애플리케이션으로 구성되며, MySQL 데이터베이스에 영구 데이터를 저장하고 Redis에 임시 게임 상태를 저장한다. 이미지 파일은 AWS S3에 저장되며, 전체 시스템은 AWS EC2에서 Docker 컨테이너로 실행된다.

3.2 백엔드 아키텍처

계층형 아키텍처 설계

KoSpot 백엔드 시스템은 4계층 아키텍처로 구성된다:

Presentation Layer (표현 계층)
- HTTP 요청/응답 처리
- WebSocket 메시지 처리
- DTO 변환 및 검증
- 클라이언트와의 인터페이스 담당

Application Layer (응용 계층)
- 비즈니스 유스케이스 구현
- 트랜잭션 관리
- 도메인 서비스 조율
- 이벤트 발행

Domain Layer (도메인 계층)
- 핵심 비즈니스 로직
- 엔티티 및 값 객체
- 도메인 규칙
- 비즈니스 불변성 보장

Infrastructure Layer (인프라 계층)
- 데이터베이스 접근 (JPA Repository)
- 외부 서비스 연동 (Redis, S3)
- WebSocket 메시징
- 타이머 및 스케줄링

이러한 계층 분리는 관심사의 분리(Separation of Concerns) 원칙을 따르며, 각 계층의 독립적인 테스트와 유지보수를 가능하게 한다.

Domain-Driven Design 적용

Domain-Driven Design(DDD)은 복잡한 비즈니스 도메인을 모델링하고 구현하는 방법론이다. KoSpot 시스템에서는 다음과 같은 DDD 개념을 적용하였다:

엔티티(Entity): 고유 식별자를 가진 도메인 객체
- Member: 사용자 정보
- GameRoom: 게임 방
- MultiRoadViewGame: 멀티플레이어 게임
- RoadViewGameRound: 게임 라운드

값 객체(Value Object): 식별자가 없는 불변 객체
- Address: 주소 정보
- PlayStreak: 연속 플레이 정보

도메인 서비스(Domain Service): 여러 엔티티에 걸친 비즈니스 로직
- GameRoomService: 게임 방 관리 로직
- RoadViewGameRoundService: 라운드 관리 로직

리포지토리(Repository): 엔티티의 영속성 관리
- 각 도메인별 Repository 인터페이스 정의
- Infrastructure 계층에서 구현

이러한 구조를 통해 비즈니스 로직이 도메인 계층에 집중되어, 기술적 세부사항과 분리되어 유지보수성이 향상된다.

3.3 프론트엔드 아키텍처

Vue 3 Composition API 기반 구조

KoSpot 프론트엔드는 Vue 3의 Composition API를 기반으로 구성되었다. Composition API는 로직의 재사용성과 코드의 가독성을 향상시키며, TypeScript와의 통합을 용이하게 한다.

Feature-based 모듈 구조

프론트엔드는 기능별로 모듈화된 구조를 채택하였다:

프론트엔드는 src 디렉토리 하위에 core, features, router, store, shared 등의 디렉토리로 구성된다. core 디렉토리에는 핵심 기능인 API 클라이언트, 공통 컴포넌트, Vue 3 Composables, 환경설정 관리, 상수 정의가 포함된다. features 디렉토리에는 기능별 모듈인 인증, 게임(싱글 플레이어, 멀티플레이어, 공유 컴포넌트), 메인 페이지, 사용자 관리, 상점이 포함된다. router 디렉토리에는 라우팅 설정이, store 디렉토리에는 Pinia를 사용한 상태 관리가, shared 디렉토리에는 공유 리소스가 포함된다.

이러한 구조는 각 기능의 독립성을 보장하며, 코드의 유지보수성과 확장성을 향상시킨다.

상태 관리 (Pinia)

Pinia를 사용하여 전역 상태를 관리한다. 주요 스토어 모듈은 다음과 같다:

- auth: 인증 상태 관리
- game: 게임 상태 관리 (라운드, 점수, 플레이어 정보 등)
- user: 사용자 정보 관리
- ui: UI 상태 관리 (모달, 토스트 등)

라우팅 구조

Vue Router를 사용하여 기능별로 라우트를 분리 관리한다:

- mainRoutes: 메인 페이지
- roadViewRoutes: 로드뷰 게임
- photoRoutes: 포토 모드 게임
- multiplayerRoutes: 멀티플레이어 게임
- userRoutes: 사용자 관련 페이지

이러한 구조는 코드의 가독성을 높이고, 각 기능의 독립적인 개발을 가능하게 한다.

Composables 패턴

재사용 가능한 로직을 Composables로 분리하여 코드의 재사용성을 높였다:

- useAuth: 인증 관련 로직
- useGame: 게임 관련 로직
- useWebSocket: WebSocket 연결 및 메시지 처리

3.4 데이터베이스 설계

ERD 설계

KoSpot 시스템의 데이터베이스는 다음과 같은 주요 엔티티로 구성된다:

Member (회원)
- 사용자 기본 정보 (아이디, 닉네임, 이메일)
- 포인트, 장착한 마커 이미지
- 현재 참여 중인 게임 방 ID

GameRoom (게임 방)
- 방 제목, 게임 모드, 매치 타입
- 시간 제한, 최대 인원, 비밀번호
- 호스트 정보
- 방 상태 (대기 중, 게임 중, 종료)

MultiRoadViewGame (멀티 로드뷰 게임)
- 게임 방과의 연관
- 현재 라운드, 총 라운드 수
- 게임 상태

RoadViewGameRound (로드뷰 게임 라운드)
- 게임과의 연관
- 라운드 번호, 정답 좌표
- 시간 제한, 서버 시작 시간
- 라운드 완료 여부

GamePlayer (게임 플레이어)
- 멤버와의 연관
- 게임과의 연관
- 팀 번호, 라운드 순위, 총 점수
- 플레이어 상태

Coordinate (좌표)
- 위도, 경도
- POI 이름, 주소 정보
- 지역 타입, 유효성

Item (아이템)
- 아이템 이름, 설명, 가격
- 재고, 아이템 타입
- 이미지 정보

MemberItem (회원 아이템)
- 회원과 아이템의 연관
- 구매 일시, 장착 여부

GameRank (게임 랭크)
- 회원과의 연관
- 게임 모드별 랭크 점수
- 티어, 레벨

MemberStatistic (회원 통계)
- 회원과의 일대일 관계
- 게임 모드별 통계
- 연속 플레이 정보

주요 엔티티 및 관계

- Member ↔ GameRoom: 일대다 관계 (한 회원은 여러 게임 방을 생성할 수 있음)
- GameRoom ↔ MultiRoadViewGame: 일대일 관계
- MultiRoadViewGame ↔ RoadViewGameRound: 일대다 관계
- MultiRoadViewGame ↔ GamePlayer: 일대다 관계
- RoadViewGameRound ↔ Coordinate: 다대일 관계

데이터 모델링 전략

정규화: 기본적으로 3정규형을 따르되, 성능을 위해 필요한 경우 비정규화를 적용
- 라운드의 서버 시작 시간을 라운드 엔티티에 비정규화하여 저장 (타이머 동기화를 위한 빠른 조회)

인덱싱 전략:
- Member: username, nickname에 인덱스
- Coordinate: sido(시도)에 인덱스 (지역별 조회 최적화)
- MemberStatistic: member_id에 인덱스

소프트 삭제: Coordinate 엔티티에 isValid 플래그를 두어 논리적 삭제 구현

4. 주요 기능 구현

4.1 싱글 플레이어 게임

싱글 플레이어 게임은 연습 모드와 랭크 모드로 구분된다.

백엔드 구현

연습 모드: 랭크에 영향을 주지 않는 자유로운 플레이 모드
- 지역(시도) 선택 가능
- 포인트 보상 제공 (점수 기반)
- 게임 기록 저장

랭크 모드: 랭크 점수가 변동하는 경쟁 모드
- 랜덤 지역에서 게임 진행
- 티어별 포인트 배율 적용
- 랭크 점수 변동

각 게임은 5라운드로 구성되며, 각 라운드마다 주어진 시간 내에 정답 좌표를 추론해야 한다. 정확도에 따라 점수가 부여되며, 최종 점수에 따라 포인트와 랭크 점수가 결정된다.

프론트엔드 구현

싱글 플레이어 게임은 다음과 같은 화면으로 구성된다:

1. 게임 모드 선택 화면: 로드뷰/포토 모드 선택, 연습/랭크 모드 선택
2. 게임 진행 화면: 
   - 로드뷰 모드: 로드뷰 컨테이너와 지도가 함께 표시되어 사용자가 로드뷰를 탐색하며 지도에 마커를 찍을 수 있음
   - 포토 모드: 관광지 사진 그리드와 지역 선택 지도가 표시됨
3. 결과 화면: 각 라운드별 점수, 거리, 순위 등이 표시됨

RESTful API 설계

KoSpot API는 RESTful 원칙을 따르며, 다음과 같은 설계 원칙을 적용하였다:

- 리소스 중심 설계: URL은 리소스를 나타내며, HTTP 메서드로 동작을 표현
- 일관된 응답 형식: 모든 API는 공통 응답 형식을 사용
- 에러 처리: HTTP 상태 코드와 커스텀 에러 코드를 함께 사용

주요 API:
- 싱글 게임 시작/종료
- 정답 제출
- 다음 라운드 진행

[플레이 사진 삽입 위치 2]
- 로드뷰 게임 진행 화면: 로드뷰 컨테이너와 지도가 함께 표시된 화면
- 포토 모드 게임 진행 화면: 사진 그리드와 지역 선택 지도가 표시된 화면
- 결과 화면: 라운드별 점수와 거리가 표시된 화면
- 기획 의도: 실제 환경 탐색의 몰입감을 제공하고, 직관적인 인터랙션을 통해 사용자가 쉽게 위치를 추론할 수 있도록 설계. 결과 화면에서는 정확한 피드백을 제공하여 학습 효과를 극대화.

4.2 멀티플레이어 게임

멀티플레이어 게임은 게임 방을 생성하거나 참여하여 진행된다.

백엔드 구현

게임 방 기능:
- 공개 방 / 비공개 방 (비밀번호 설정)
- 최대 인원 설정 (2~8명)
- 게임 모드 선택 (로드뷰, 포토)
- 매치 타입 선택 (개인전, 팀전)
- 시간 제한 설정

게임 방 관리 전략

게임 방의 상태는 Redis에 저장되어 빠른 조회와 업데이트가 가능하다. Redis를 사용한 이유는 다음과 같다:

1. 빠른 성능: 인메모리 저장으로 밀리초 단위 응답
2. 다양한 데이터 구조: Hash, Set, List 등을 활용한 효율적 데이터 관리
3. Pub/Sub 기능: 메시징에도 활용 가능
4. TTL 지원: 자동 만료 기능으로 메모리 관리

Redis 데이터 구조:
- room:{roomId}:players: 게임 방 플레이어 정보 (Hash)
- room:{roomId}:state: 게임 방 상태 (String)
- room:{roomId}:player_loading_status: 플레이어 로딩 상태 (Hash)

게임 방의 영구 정보(제목, 설정 등)는 MySQL에 저장하고, 실시간 상태는 Redis에 저장하는 하이브리드 방식을 사용한다.

게임 플로우 설계

멀티플레이어 게임은 다음과 같은 플로우로 진행된다:

1. 게임 대기 (WAITING): 플레이어 입장 대기, 방 설정 변경 가능, 채팅 가능
2. 게임 시작 요청: 호스트가 게임 시작 버튼 클릭, 최소 인원 확인 (2명 이상), 게임 및 첫 라운드 생성
3. 카운트다운 (COUNTDOWN): 3초 카운트다운 브로드캐스트, 모든 플레이어에게 게임 페이지 이동 알림
4. 로딩 단계 (LOADING): 플레이어가 게임 페이지 로딩 완료 시 ACK 전송, 모든 플레이어 로딩 완료 대기 (최대 10초)
5. 인트로 (INTRO): 라운드 문제 정보 브로드캐스트, 5초 인트로 화면 표시
6. 라운드 진행 (IN_ROUND): 타이머 시작, 플레이어 정답 제출, 모든 플레이어 제출 완료 시 조기 종료
7. 라운드 종료: 결과 계산 및 브로드캐스트, 10초 전환 대기
8. 다음 라운드 또는 게임 종료: 마지막 라운드가 아니면 다음 라운드 진행, 마지막 라운드면 최종 결과 표시

라운드 관리 및 동기화

라운드는 게임의 기본 단위이며, 다음과 같이 관리된다:

- 라운드 생성: 게임 시작 시 첫 라운드 생성, 각 라운드는 랜덤 좌표 선택
- 라운드 진행: 서버 시작 시간 기록 (타이머 동기화용), 플레이어 제출 정보는 Redis에 저장
- 라운드 종료: 타이머 만료 또는 모든 플레이어 제출 완료 시 종료, 각 플레이어의 거리 계산 및 점수 부여
- 조기 종료 로직: 모든 플레이어가 정답을 제출하면 라운드를 조기 종료하여 게임의 흐름을 빠르게 유지

프론트엔드 구현

멀티플레이어 게임은 다음과 같은 화면으로 구성된다:

1. 멀티플레이어 로비: 게임 방 목록, 방 생성, 글로벌 채팅
2. 게임 방 화면: 플레이어 목록, 방 설정, 방 내 채팅, 게임 시작 버튼
3. 게임 진행 화면: 
   - 개인전: 플레이어 목록과 점수 표시, 실시간 채팅
   - 팀전: 팀별 점수 표시, 팀 채팅
4. 결과 화면: 최종 순위, 팀 점수(팀전), 다음 게임 유도

플레이어 상태 동기화

플레이어의 게임 내 상태는 다음과 같이 관리된다:

- Redis에 현재 게임 방 ID, 팀 번호, 준비 상태 등 저장
- 게임 시작 시 GamePlayer 엔티티 생성 (MySQL)
- 게임 진행 중 점수, 순위 등은 Redis와 DB 모두 업데이트
- 플레이어 입장/퇴장 시 WebSocket으로 브로드캐스트

[플레이 사진 삽입 위치 3]
- 멀티플레이어 로비 화면: 게임 방 목록과 글로벌 채팅이 표시된 화면
- 게임 방 화면: 플레이어 목록, 방 설정, 채팅이 표시된 화면
- 게임 진행 화면: 플레이어 마커가 지도에 표시되고 실시간 상호작용이 이루어지는 화면
- 결과 화면: 순위와 팀 점수가 표시된 화면
- 기획 의도: 실시간 상호작용을 통해 경쟁 요소를 강화하고, 사회적 연결을 통해 게임의 지속성을 높임. 플레이어 간의 상호작용(채팅, 마커 표시)을 통해 몰입감을 극대화.

4.3 실시간 통신 구현

STOMP 프로토콜 선택 이유

멀티플레이어 게임에서는 여러 클라이언트 간의 실시간 동기화가 필수적이다. 이를 위해 WebSocket을 선택하였으며, STOMP 프로토콜을 사용한 이유는 다음과 같다:

1. Pub/Sub 패턴 지원: 게임 방 단위로 메시지를 브로드캐스트하기에 적합
2. 채널 기반 메시징: 게임 방별, 게임 상태별로 채널을 구분하여 관리 용이
3. Spring 통합: Spring WebSocket과의 자연스러운 통합
4. 브라우저 호환성: SockJS를 통한 폴백 지원

채널 구조 설계

WebSocket 채널은 다음과 같이 구성된다:

글로벌 채널:
- /topic/lobby: 로비 채팅

게임 방 채널:
- /topic/room/{roomId}/chat: 게임 방 채팅
- /topic/room/{roomId}/playerList: 플레이어 목록 변경
- /topic/room/{roomId}/status: 방 상태 변경
- /topic/room/{roomId}/countdown: 게임 시작 카운트다운

게임 진행 채널:
- /topic/room/{roomId}/game/{gameId}/timer: 타이머 동기화
- /topic/room/{roomId}/game/{gameId}/round/{roundId}/result: 라운드 결과
- /topic/room/{roomId}/game/{gameId}/round/{roundId}/transition: 라운드 전환

이러한 구조는 게임 방 단위로 메시지를 격리하여, 다른 방의 메시지가 섞이지 않도록 보장한다.

메시지 브로드캐스팅 메커니즘

게임 상태 변경 시 해당 게임 방의 모든 플레이어에게 메시지를 브로드캐스트해야 한다. 이를 위해 Spring의 SimpMessagingTemplate을 사용한다.

브로드캐스트 시나리오:
1. 플레이어 입장: /topic/room/{roomId}/playerList로 플레이어 목록 전송
2. 게임 시작: 카운트다운 메시지 브로드캐스트
3. 라운드 시작: 타이머 시작 메시지 브로드캐스트
4. 라운드 종료: 결과 메시지 브로드캐스트
5. 게임 종료: 최종 결과 메시지 브로드캐스트

각 메시지는 JSON 형식으로 전송되며, 클라이언트는 구독한 채널을 통해 메시지를 수신한다.

타이머 동기화 구현

멀티플레이어 게임에서 모든 플레이어의 타이머가 동기화되어야 한다. 이를 위해 다음과 같은 방법을 사용한다:

서버 시간 기반 동기화:
- 라운드 시작 시 서버 시간(서버 시작 시간)을 클라이언트에 전송
- 클라이언트는 서버 시간과 라운드 지속 시간을 받아 로컬 타이머 계산
- 5초마다 서버에서 남은 시간을 브로드캐스트하여 동기화 보정

타이머 관리:
- 서버에서 TaskScheduler를 사용하여 라운드 종료 시간에 이벤트 발행
- 모든 플레이어가 제출 완료 시 조기 종료 이벤트 발행
- 라운드 전환 대기 시간(10초)도 서버에서 관리

이러한 방식으로 네트워크 지연이나 클라이언트 시간 불일치 문제를 해결한다.

프론트엔드 WebSocket 구현

프론트엔드에서는 @stomp/stompjs와 sockjs-client를 사용하여 WebSocket 연결을 관리한다. useWebSocket composable을 통해 WebSocket 연결, 채널 구독, 메시지 전송 등의 기능을 제공한다.

4.4 랭킹 및 포인트 시스템

랭킹 시스템

랭킹 시스템은 게임 모드별로 독립적으로 관리된다.

티어 시스템:
- BRONZE (0~999점)
- SILVER (1000~1499점)
- GOLD (1500~1999점)
- PLATINUM (2000~2499점)
- DIAMOND (2500~2999점)
- MASTER (3000~3499점)
- GRANDMASTER (3500~3999점)
- CHALLENGER (4000점 이상)

랭크 점수 계산:
- 게임 결과에 따라 점수 변동
- 상대적 성과에 따라 가감점 결정
- 중도 이탈 시 패널티 적용

포인트 시스템

포인트 획득:
- 게임 완료 시 포인트 획득
- 연습 모드: 기본 30P + (점수 × 0.08)
- 랭크 모드: (기본 50P + 점수 × 0.2) × 티어 배율

아이템 시스템:
- 마커 스킨: 게임 내 마커 이미지 변경
- 프로필 아이템: 프로필 꾸미기
- 이펙트: 게임 내 효과
- 테마: UI 테마 변경

포인트는 아이템 구매에 사용되며, 게임 지속성을 높이는 요소로 작용한다.

5. 사용자 인터페이스 및 경험

5.1 UI/UX 디자인 원칙

KoSpot의 사용자 인터페이스는 다음과 같은 디자인 원칙을 기반으로 설계되었다:

Perfect balance functional design: 기능성과 미적 균형을 추구하여 사용자가 직관적으로 기능을 이해하고 사용할 수 있도록 설계하였다.

Soft, refreshing gradient colors: 브랜드 팔레트와 조화되는 부드러운 그라데이션 색상을 사용하여 시각적 피로를 줄이고 몰입감을 높였다.

Well-proportioned white space: 깔끔한 레이아웃을 위한 균형 잡힌 여백을 통해 정보의 가독성을 향상시켰다.

Light and immersive: 가벼우면서 몰입감 있는 사용자 경험을 제공하기 위해 불필요한 요소를 제거하고 핵심 기능에 집중하였다.

Clear information hierarchy: 미묘한 그림자와 모듈식 카드 레이아웃으로 명확한 정보 계층을 구축하여 사용자가 쉽게 정보를 파악할 수 있도록 하였다.

Natural focus: 핵심 기능에 자연스러운 집중을 유도하기 위해 시각적 강조와 애니메이션을 활용하였다.

Refined rounded corners: 세련된 둥근 모서리를 통해 현대적이고 친근한 느낌을 제공하였다.

Delicate micro-interactions: 섬세한 마이크로 인터랙션을 통해 사용자 액션에 대한 즉각적인 피드백을 제공하여 사용자 경험을 향상시켰다.

Comfortable visual proportions: 편안한 시각적 비율을 유지하여 장시간 사용 시에도 피로감을 최소화하였다.

All text should be only black or white: 모든 텍스트는 검은색 또는 흰색만 사용하여 가독성과 일관성을 확보하였다.

5.2 주요 화면 구성 및 플레이 플로우

메인 페이지

메인 페이지는 사용자가 처음 접하는 화면으로, 게임 모드 선택, 사용자 정보, 공지사항 등이 표시된다.

- 게임 모드 선택: 로드뷰 모드, 포토 모드, 멀티플레이어 모드가 카드 형태로 표시되어 직관적인 선택이 가능하다.
- 사용자 정보 카드: 로그인 상태에 따라 로그인 유도 또는 사용자 정보가 표시된다.
- 공지사항 섹션: 최근 공지사항이 목록 형태로 표시되어 중요한 정보를 쉽게 확인할 수 있다.

싱글 플레이어 게임 플로우

1. 게임 모드 선택: 메인 페이지에서 로드뷰 또는 포토 모드를 선택
2. 게임 설정: 연습 모드 또는 랭크 모드 선택, 연습 모드의 경우 지역 선택
3. 게임 진행: 
   - 로드뷰 모드: 로드뷰 컨테이너에서 환경을 탐색하며 지도에 마커를 찍어 위치 추론
   - 포토 모드: 관광지 사진을 보고 지역을 선택하여 위치 추론
4. 결과 확인: 각 라운드별 점수, 거리, 순위 등이 표시됨
5. 최종 결과: 전체 라운드 결과와 포인트 획득 정보가 표시됨

멀티플레이어 게임 플로우

1. 로비 입장: 멀티플레이어 로비에서 게임 방 목록 확인
2. 방 생성 또는 참여: 새 방을 생성하거나 기존 방에 참여
3. 방 대기: 플레이어 입장 대기, 방 설정 변경, 채팅
4. 게임 시작: 호스트가 게임 시작 버튼 클릭, 3초 카운트다운
5. 게임 진행: 모든 플레이어가 동시에 게임을 진행하며 실시간으로 상호작용
6. 결과 확인: 라운드별 결과와 최종 순위가 표시됨

화면 전환 시 사용자 경험 고려사항

- 로딩 상태 표시: 데이터 로딩 중에는 로딩 스피너를 표시하여 사용자에게 진행 상황을 알림
- 에러 처리: 에러 발생 시 명확한 에러 메시지와 함께 해결 방법을 제시
- 애니메이션: 화면 전환 시 부드러운 애니메이션을 적용하여 자연스러운 사용자 경험 제공
- 반응형 디자인: 모바일과 데스크톱 환경 모두에서 최적화된 레이아웃 제공

5.3 플레이 사진 및 시나리오별 기획 의도

메인 페이지

[플레이 사진 삽입 위치 1]
- 메인 페이지 전체 화면: 게임 모드 선택 카드, 사용자 정보 카드, 공지사항 섹션이 표시된 화면
- 기획 의도: 직관적인 게임 모드 선택을 통해 사용자가 쉽게 원하는 게임을 시작할 수 있도록 설계. 첫 방문자를 위한 온보딩 프로세스(닉네임 설정, 튜토리얼)를 통해 서비스 사용법을 자연스럽게 안내.

싱글 플레이어 게임

[플레이 사진 삽입 위치 2]
- 로드뷰 게임 진행 화면: 로드뷰 컨테이너와 지도가 함께 표시된 화면, 사용자가 로드뷰를 탐색하며 지도에 마커를 찍는 모습
- 포토 모드 게임 진행 화면: 관광지 사진 그리드와 지역 선택 지도가 표시된 화면
- 결과 화면: 라운드별 점수, 거리, 순위가 표시된 화면
- 기획 의도: 실제 환경 탐색의 몰입감을 제공하고, 직관적인 인터랙션을 통해 사용자가 쉽게 위치를 추론할 수 있도록 설계. 결과 화면에서는 정확한 피드백을 제공하여 학습 효과를 극대화.

멀티플레이어 게임

[플레이 사진 삽입 위치 3]
- 멀티플레이어 로비 화면: 게임 방 목록과 글로벌 채팅이 표시된 화면
- 게임 방 화면: 플레이어 목록, 방 설정, 채팅이 표시된 화면
- 게임 진행 화면: 플레이어 마커가 지도에 표시되고 실시간 상호작용이 이루어지는 화면
- 결과 화면: 순위와 팀 점수가 표시된 화면
- 기획 의도: 실시간 상호작용을 통해 경쟁 요소를 강화하고, 사회적 연결을 통해 게임의 지속성을 높임. 플레이어 간의 상호작용(채팅, 마커 표시)을 통해 몰입감을 극대화.

UI 컴포넌트 및 반응형 디자인

[플레이 사진 삽입 위치 4]
- 주요 UI 컴포넌트: 버튼, 모달, 카드 등 일관된 디자인 시스템이 적용된 컴포넌트들
- 반응형 디자인: 모바일과 데스크톱 환경에서 최적화된 레이아웃
- 기획 의도: 일관된 디자인 시스템을 통해 사용자에게 친숙한 경험을 제공하고, 접근성을 고려한 반응형 디자인으로 다양한 기기에서 사용 가능하도록 설계.

6. 기술 스택 및 배포

6.1 사용 기술 스택

백엔드 프레임워크

Spring Boot 3.4.1
- Java 17 기반의 엔터프라이즈 애플리케이션 개발 프레임워크
- 자동 설정과 스타터 의존성을 통한 빠른 개발
- 내장 서버로 독립 실행 가능
- 선택 이유: 풍부한 생태계, 검증된 안정성, 다양한 통합 기능

Spring Data JPA
- JPA를 통한 객체-관계 매핑
- Repository 패턴의 자동 구현
- 쿼리 메서드 자동 생성
- 선택 이유: 생산성 향상, 타입 안정성, 코드 간결성

Spring Security + OAuth2
- 인증 및 권한 관리
- 소셜 로그인 지원 (구글, 네이버, 카카오)
- JWT 토큰 기반 인증
- 선택 이유: 표준 보안 프레임워크, 다양한 인증 방식 지원

프론트엔드 프레임워크

Vue 3
- Composition API 기반의 현대적인 프레임워크
- 반응형 시스템을 통한 효율적인 상태 관리
- 컴포넌트 기반 아키텍처로 재사용성 향상
- 선택 이유: 학습 곡선이 낮고, 생태계가 풍부하며, 성능이 우수함

Vue Router
- 클라이언트 사이드 라우팅
- 기능별 라우트 모듈 분리
- 선택 이유: Vue 생태계와의 자연스러운 통합, 간편한 설정

Pinia
- Vue 3 공식 상태 관리 라이브러리
- 모듈화된 스토어 구조
- 선택 이유: Vuex의 후속 버전으로, 더 간단하고 타입 안전한 API 제공

Axios
- HTTP 클라이언트 라이브러리
- 요청/응답 인터셉터를 통한 토큰 관리
- 선택 이유: 널리 사용되는 라이브러리, 간편한 API

@stomp/stompjs + sockjs-client
- WebSocket 클라이언트 라이브러리
- STOMP 프로토콜 지원
- 선택 이유: 실시간 통신 구현, 브라우저 호환성

데이터베이스 및 캐시

MySQL 8
- 관계형 데이터베이스
- 영구 데이터 저장
- ACID 트랜잭션 보장
- 선택 이유: 안정성, 성숙도, 넓은 사용자 기반

Redis
- 인메모리 데이터베이스
- 게임 방 상태, 플레이어 정보 등 임시 데이터 저장
- Pub/Sub 기능을 통한 메시징
- 선택 이유: 빠른 성능, 다양한 데이터 구조, 실시간 기능 지원

실시간 통신 기술

WebSocket + STOMP
- WebSocket: 양방향 실시간 통신
- STOMP: 메시징 프로토콜
- SockJS: WebSocket 폴백 지원
- 선택 이유: 실시간 동기화 필요, Pub/Sub 패턴 지원, 브라우저 호환성

Spring WebSocket
- STOMP 메시지 브로커
- 채널 기반 메시징
- 선택 이유: Spring 생태계 통합, 간편한 설정

인증 및 보안

JWT (JSON Web Token)
- Access Token과 Refresh Token 분리
- Stateless 인증
- 선택 이유: 확장성, 서버 부하 감소

OAuth2
- 소셜 로그인 통합
- 구글, 네이버, 카카오 지원
- 선택 이유: 사용자 편의성, 보안성

6.2 배포 시스템

Docker 컨테이너화

KoSpot 애플리케이션은 Docker를 통해 컨테이너화되어 배포된다. Dockerfile은 멀티 스테이지 빌드를 사용하여 최적화된 이미지를 생성한다.

빌드 스테이지: Gradle을 사용하여 애플리케이션을 빌드
런타임 스테이지: OpenJDK 17을 기반으로 실행 환경 구성

이러한 구조는 최종 이미지 크기를 줄이고 보안을 강화한다. 또한 비루트 사용자로 실행하여 보안 취약점을 최소화한다.

Docker Compose를 통해 애플리케이션과 Redis를 함께 관리하며, 네트워크를 통한 서비스 간 통신을 구성한다.

AWS 인프라 구성

EC2 인스턴스
- Ubuntu 22.04 LTS
- Docker 및 Docker Compose 설치
- 애플리케이션 실행 환경

RDS MySQL
- 관리형 데이터베이스 서비스
- 자동 백업 및 패치
- 고가용성 구성

S3 버킷
- 이미지 파일 저장
- 정적 리소스 제공
- 버전 관리 및 라이프사이클 정책

Nginx
- 리버스 프록시
- SSL/TLS 종료
- 로드 밸런싱 (향후 확장 시)

CI/CD 파이프라인

GitHub Actions 워크플로우:
1. 코드 푸시 시 자동 트리거
2. 테스트 실행
3. Docker 이미지 빌드
4. S3에 배포 패키지 업로드
5. CodeDeploy를 통한 EC2 배포

CodeDeploy 배포 단계:
1. Before Install: 기존 컨테이너 중지
2. After Install: Docker 이미지 로드
3. Application Start: 컨테이너 시작
4. Validate Service: 헬스 체크

이러한 자동화된 파이프라인을 통해 배포 시간을 단축하고 인적 오류를 최소화한다.

7. 성능 최적화 및 개선

7.1 백엔드 최적화

랜덤 좌표 조회 최적화

게임에서 랜덤 좌표를 조회하는 작업은 빈번하게 발생한다. 초기에는 ORDER BY RAND()를 사용하였으나, 데이터가 많아질수록 성능이 저하되는 문제가 있었다.

최적화 방법:
1. ID 범위 샘플링: 전체 데이터의 ID 범위를 계산하고, 랜덤 ID를 선택하여 조회
2. 캐시 테이블: 지역별 ID 범위를 미리 계산하여 캐시
3. 지역별 테이블 분리: 시도별로 데이터를 분리하여 조회 범위 축소

이러한 최적화를 통해 조회 시간을 크게 단축하였다.

게임 종료 로직 비동기 처리

게임 종료 시 여러 작업이 수행된다:
- 결과 계산
- 통계 업데이트
- 포인트 지급
- 랭크 점수 업데이트

초기에는 모든 작업을 동기적으로 처리하여 응답 시간이 길었다.

최적화 방법:
- 주요 로직(결과 반환)은 동기 처리
- 부가 로직(통계, 포인트, 랭크)은 @Async를 사용한 비동기 처리
- 트랜잭션 분리로 부가 로직의 예외가 주요 로직에 영향 없도록 처리

이를 통해 응답 시간을 1400ms에서 3ms로 단축하였다.

Redis 캐싱 전략

Redis는 다음과 같은 용도로 활용된다:

게임 상태 캐싱:
- 게임 방 정보
- 플레이어 정보
- 라운드 제출 정보

캐시 전략:
- 자주 조회되는 데이터는 Redis에 저장
- TTL 설정으로 자동 만료
- 게임 종료 시 명시적 삭제

캐시 무효화:
- 데이터 변경 시 Redis와 DB 모두 업데이트
- 게임 종료 시 관련 캐시 삭제

7.2 프론트엔드 최적화

컴포넌트 최적화

- Lazy Loading: 라우트별 코드 스플리팅을 통해 초기 로딩 시간 단축
- 컴포넌트 재사용: 공통 컴포넌트를 최대한 재사용하여 번들 크기 감소
- 이미지 최적화: 필요한 이미지만 로드하고, 지연 로딩 적용

상태 관리 최적화

- Pinia 모듈화: 기능별로 스토어를 분리하여 필요한 상태만 관리
- Computed 속성 활용: 파생 상태는 computed 속성으로 계산하여 불필요한 재계산 방지
- 메모이제이션: 반복 계산이 필요한 경우 메모이제이션 적용

렌더링 최적화

- v-show vs v-if: 자주 토글되는 요소는 v-show 사용
- 키 최적화: 리스트 렌더링 시 적절한 key 사용
- 가상 스크롤: 긴 목록의 경우 가상 스크롤 적용

7.3 성능 개선 결과

백엔드 최적화를 통해 게임 종료 응답 시간이 1400ms에서 3ms로 단축되었으며, 랜덤 좌표 조회 시간도 크게 개선되었다. 프론트엔드 최적화를 통해 초기 로딩 시간이 단축되고, 사용자 인터랙션에 대한 응답성이 향상되었다.

8. 사용자 피드백 및 결론

8.1 사용자 피드백 분석

긍정 피드백

실제 서비스 운영을 통해 수집한 사용자 피드백은 다음과 같다:

1. 로드뷰를 통한 위치 추론의 재미
- "로드뷰로 둘러보면서 위치를 추측하는 것이 재밌다"
- 실제 환경을 탐색하는 과정이 게임의 핵심 재미 요소로 작용

2. 지리 학습 효과
- "지리에 대한 개념이 잘 없었는데, 지도를 보다보니 우리나라 지리에 대해 조금 익숙해졌다"
- 게임을 통해 자연스럽게 지리 지식 습득

3. 멀티플레이어 기능
- "친구랑 같이 플레이할 수 있다는 것이 재밌다"
- 사회적 상호작용을 통한 학습 동기 부여

4. 랭킹 시스템
- "랭킹 시스템으로 플레이 동기가 유발되어 좋다"
- 경쟁 요소가 게임 지속성에 기여

개선 피드백

1. 지리 관심도가 낮은 사용자의 지속적 플레이 어려움
- 지리에 전혀 관심이 없는 사용자들은 게임에 지속적으로 참여하기 어려움
- 해결 방안: 다양한 게임 모드 추가, 힌트 시스템 강화, 난이도 조절 옵션

2. 난이도 조절 필요성
- "너무 맞추기 어려운 좌표가 나오면 하고싶지 않다"
- 사용자 실력에 맞는 난이도 제공 필요
- 해결 방안: 사용자 실력 기반 좌표 추천, 난이도 선택 옵션

8.2 향후 개선 방향

난이도 조절 시스템:
- 사용자 실력 분석을 통한 적절한 난이도 제공
- 초보자용 쉬운 모드, 고수용 어려운 모드 분리
- 힌트 시스템 강화

게임 모드 다양화:
- 포토 모드 외 추가 모드 개발
- 퀴즈 모드, 시간 제한 모드 등

학습 기능 강화:
- 게임 종료 후 해당 지역 정보 제공
- 히스토리 기능으로 방문한 지역 기록
- 학습 통계 제공

소셜 기능 강화:
- 친구 시스템
- 리플레이 공유
- 커뮤니티 기능

8.3 결론

본 연구에서는 한국의 관광지를 로드뷰와 포토를 통해 재미있게 위치를 맞추는 게임 서비스인 KoSpot을 개발하였다. WebSocket 기반의 실시간 통신 시스템을 구축하여 멀티플레이어 게임을 구현하였으며, Redis를 활용한 게임 상태 관리로 효율적인 동기화를 달성하였다.

백엔드는 Domain-Driven Design 원칙을 적용한 계층형 아키텍처로 설계하여 유지보수성과 확장성을 확보하였으며, 프론트엔드는 Vue 3 Composition API 기반의 Feature-based 모듈 구조로 구성하여 코드의 재사용성과 가독성을 향상시켰다. 사용자 인터페이스는 기능성과 미적 균형을 추구하는 디자인 원칙을 적용하여 직관적이고 몰입감 있는 사용자 경험을 제공하도록 설계하였다.

Docker와 AWS를 활용한 클라우드 인프라로 안정적인 서비스를 제공할 수 있도록 구성하였으며, 성능 최적화를 통해 게임 종료 응답 시간을 1400ms에서 3ms로 단축하는 등의 성과를 달성하였다.

실제 서비스 운영을 통해 사용자들은 로드뷰를 통한 위치 추론의 재미와 지리 학습 효과에 대해 긍정적인 피드백을 제공하였으며, 멀티플레이어 기능과 랭킹 시스템이 게임 지속성을 높이는 데 기여함을 확인하였다.

다만 지리 관심도가 낮은 사용자들의 지속적 플레이 어려움과 난이도 조절의 필요성 등의 개선점도 발견되어, 향후 이러한 부분에 대한 개선이 필요하다.

향후 연구에서는 사용자 실력 분석을 통한 적절한 난이도 제공 시스템, 다양한 게임 모드 추가, 학습 기능 강화 등을 통해 서비스를 개선할 계획이다.

참고문헌

1. Evans, E. (2003). Domain-Driven Design: Tackling Complexity in the Heart of Software. Addison-Wesley Professional.

2. Spring Framework Documentation. (2024). Spring WebSocket Support. https://docs.spring.io/spring-framework/reference/web/websocket.html

3. Redis Documentation. (2024). Redis Data Structures. https://redis.io/docs/data-structures/

4. Docker Documentation. (2024). Docker Overview. https://docs.docker.com/get-started/overview/

5. AWS Documentation. (2024). Amazon EC2 User Guide. https://docs.aws.amazon.com/ec2/

6. Deterding, S., Dixon, D., Khaled, R., & Nacke, L. (2011). From game design elements to gamefulness: defining "gamification". Proceedings of the 15th international academic MindTrek conference: Envisioning future media environments.

7. Zichermann, G., & Cunningham, C. (2011). Gamification by Design: Implementing Game Mechanics in Web and Mobile Apps. O'Reilly Media.

작성일: 2025년 1월
버전: 1.0

