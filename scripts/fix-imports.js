#!/usr/bin/env node

/**
 * üöÄ Advanced Import Fixer
 * ÏûòÎ™ªÎêú import Í≤ΩÎ°úÎ•º ÏûêÎèôÏúºÎ°ú Ï∞æÏïÑÏÑú Ïò¨Î∞îÎ•∏ Í≤ΩÎ°úÎ°ú ÏàòÏ†ïÌïòÎäî Ïä§ÌÅ¨Î¶ΩÌä∏
 * 
 * Í∏∞Îä•:
 * - Íπ®ÏßÑ import ÏûêÎèô Í∞êÏßÄ
 * - ÌååÏùº ÏãúÏä§ÌÖú Í∏∞Î∞ò Ïò¨Î∞îÎ•∏ Í≤ΩÎ°ú Ï∂îÏ≤ú
 * - ÏÉÅÎåÄ/Ï†àÎåÄ Í≤ΩÎ°ú Î≥ÄÌôò
 * - Vue, JS, TS ÌååÏùº ÏßÄÏõê
 * - Î∞±ÏóÖ Î∞è Î°§Î∞± Í∏∞Îä•
 */

const fs = require('fs');
const path = require('path');
const glob = require('glob');
const chalk = require('chalk');

class ImportFixer {
    constructor(options = {}) {
        this.srcDir = options.srcDir || 'src';
        this.extensions = options.extensions || ['.js', '.vue', '.ts', '.jsx', '.tsx'];
        this.aliases = options.aliases || {
            '@': 'src',
            '@core': 'src/core',
            '@features': 'src/features',
            '@game': 'src/features/game',
            '@websocket': 'src/features/game/multiplayer/shared/services/websocket'
        };
        this.fileCache = new Map();
        this.brokenImports = [];
        this.fixedImports = [];
        this.backup = options.backup !== false;
    }

    /**
     * Î™®Îì† ÌååÏùºÏùÑ Ïä§Ï∫îÌïòÏó¨ ÌååÏùº Ï∫êÏãú ÏÉùÏÑ±
     */
    buildFileCache() {
        console.log(chalk.blue('üìÅ Building file cache...'));
        
        const patterns = this.extensions.map(ext => `${this.srcDir}/**/*${ext}`);
        const allFiles = [];
        
        patterns.forEach(pattern => {
            allFiles.push(...glob.sync(pattern));
        });

        allFiles.forEach(filePath => {
            const relativePath = path.relative(process.cwd(), filePath);
            const filename = path.basename(filePath, path.extname(filePath));
            const dirname = path.dirname(relativePath);
            
            // ÌååÏùºÎ™ÖÏúºÎ°ú Ïù∏Îç±Ïã±
            if (!this.fileCache.has(filename)) {
                this.fileCache.set(filename, []);
            }
            this.fileCache.get(filename).push({
                fullPath: relativePath,
                dir: dirname,
                isIndex: filename === 'index'
            });
        });

        console.log(chalk.green(`‚úÖ Cached ${allFiles.length} files`));
    }

    /**
     * Import Î¨∏ÏóêÏÑú ÌååÏùº Í≤ΩÎ°ú Ï∂îÏ∂ú
     */
    extractImports(content) {
        const imports = [];
        
        // ES6 import Ìå®ÌÑ¥
        const importRegex = /import\s+(?:(?:\{[^}]*\}|\*\s+as\s+\w+|\w+)(?:\s*,\s*(?:\{[^}]*\}|\*\s+as\s+\w+|\w+))*\s+from\s+)?['"`]([^'"`]+)['"`]/g;
        
        // require Ìå®ÌÑ¥
        const requireRegex = /require\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g;
        
        // dynamic import Ìå®ÌÑ¥
        const dynamicImportRegex = /import\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g;
        
        let match;
        
        // ES6 imports
        while ((match = importRegex.exec(content)) !== null) {
            imports.push({
                type: 'import',
                path: match[1],
                fullMatch: match[0],
                index: match.index
            });
        }
        
        // require calls
        while ((match = requireRegex.exec(content)) !== null) {
            imports.push({
                type: 'require',
                path: match[1],
                fullMatch: match[0],
                index: match.index
            });
        }
        
        // dynamic imports
        while ((match = dynamicImportRegex.exec(content)) !== null) {
            imports.push({
                type: 'dynamic',
                path: match[1],
                fullMatch: match[0],
                index: match.index
            });
        }
        
        return imports;
    }

    /**
     * Í≤ΩÎ°ú Ìï¥ÏÑù (alias Ï≤òÎ¶¨)
     */
    resolvePath(importPath, fromFile) {
        // Ï†àÎåÄ Í≤ΩÎ°úÎÇò node_modulesÎäî Í≤ÄÏÇ¨ÌïòÏßÄ ÏïäÏùå
        if (importPath.startsWith('http') || 
            !importPath.startsWith('.') && !importPath.startsWith('@') && !importPath.startsWith('src/')) {
            return null;
        }

        // alias Ï≤òÎ¶¨
        let resolvedPath = importPath;
        for (const [alias, realPath] of Object.entries(this.aliases)) {
            if (importPath.startsWith(alias + '/')) {
                resolvedPath = importPath.replace(alias, realPath);
                break;
            } else if (importPath === alias) {
                resolvedPath = realPath;
                break;
            }
        }

        // ÏÉÅÎåÄ Í≤ΩÎ°ú Ï≤òÎ¶¨
        if (resolvedPath.startsWith('./') || resolvedPath.startsWith('../')) {
            const fromDir = path.dirname(fromFile);
            resolvedPath = path.resolve(fromDir, resolvedPath);
            resolvedPath = path.relative(process.cwd(), resolvedPath);
        }

        return resolvedPath;
    }

    /**
     * ÌååÏùºÏù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
     */
    fileExists(filePath) {
        // ÌôïÏû•ÏûêÍ∞Ä ÏûàÎäî Í≤ΩÏö∞
        if (path.extname(filePath)) {
            return fs.existsSync(filePath);
        }

        // ÌôïÏû•ÏûêÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Í∞ÄÎä•Ìïú ÌôïÏû•ÏûêÎì§ ÏãúÎèÑ
        for (const ext of this.extensions) {
            if (fs.existsSync(filePath + ext)) {
                return true;
            }
        }

        // index ÌååÏùº ÌôïÏù∏
        for (const ext of this.extensions) {
            if (fs.existsSync(path.join(filePath, `index${ext}`))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Ïò¨Î∞îÎ•∏ import Í≤ΩÎ°ú Ï∞æÍ∏∞
     */
    findCorrectPath(importPath, fromFile) {
        const filename = path.basename(importPath, path.extname(importPath));
        const possibleFiles = this.fileCache.get(filename) || [];
        
        if (possibleFiles.length === 0) {
            return null;
        }

        const fromDir = path.dirname(fromFile);
        
        // Í∞ÄÏû• Ï†ÅÌï©Ìïú ÌååÏùº Ï∞æÍ∏∞
        let bestMatch = null;
        let bestScore = -1;

        possibleFiles.forEach(file => {
            let score = 0;
            
            // Í≤ΩÎ°ú Ïú†ÏÇ¨ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞
            const relativePath = path.relative(fromDir, file.fullPath);
            const depth = relativePath.split(path.sep).length;
            
            // ÍπäÏù¥Í∞Ä Ï†ÅÏùÑÏàòÎ°ù ÎÜíÏùÄ Ï†êÏàò
            score += Math.max(0, 10 - depth);
            
            // ÏõêÎûò Í≤ΩÎ°úÏôÄ Ïú†ÏÇ¨Ìï†ÏàòÎ°ù ÎÜíÏùÄ Ï†êÏàò
            if (importPath.includes(path.basename(file.dir))) {
                score += 5;
            }
            
            // index ÌååÏùºÏù¥Î©¥ Í∞ÄÏÇ∞Ï†ê
            if (file.isIndex) {
                score += 2;
            }

            if (score > bestScore) {
                bestScore = score;
                bestMatch = file;
            }
        });

        if (bestMatch) {
            // ÏÉÅÎåÄ Í≤ΩÎ°úÎ°ú Î≥ÄÌôò
            let relativePath = path.relative(fromDir, bestMatch.fullPath);
            if (!relativePath.startsWith('.')) {
                relativePath = './' + relativePath;
            }
            
            // ÌôïÏû•Ïûê Ï†úÍ±∞ (Vue, JSÏùò Í≤ΩÏö∞)
            const ext = path.extname(relativePath);
            if (['.js', '.vue', '.ts'].includes(ext)) {
                relativePath = relativePath.slice(0, -ext.length);
            }
            
            return relativePath.replace(/\\/g, '/'); // Windows Í≤ΩÎ°ú Ï†ïÍ∑úÌôî
        }

        return null;
    }

    /**
     * ÌååÏùºÏùò import Î¨∏Ï†ú Î∂ÑÏÑù
     */
    analyzeFile(filePath) {
        const content = fs.readFileSync(filePath, 'utf8');
        const imports = this.extractImports(content);
        const issues = [];

        imports.forEach(imp => {
            const resolvedPath = this.resolvePath(imp.path, filePath);
            if (resolvedPath && !this.fileExists(resolvedPath)) {
                const correctPath = this.findCorrectPath(imp.path, filePath);
                if (correctPath) {
                    issues.push({
                        ...imp,
                        resolvedPath,
                        correctPath,
                        file: filePath
                    });
                }
            }
        });

        return issues;
    }

    /**
     * Î∞±ÏóÖ ÏÉùÏÑ±
     */
    createBackup(filePath) {
        if (!this.backup) return;
        
        const backupDir = '.backup-imports';
        if (!fs.existsSync(backupDir)) {
            fs.mkdirSync(backupDir, { recursive: true });
        }
        
        const backupPath = path.join(backupDir, filePath.replace(/[/\\]/g, '_'));
        fs.copyFileSync(filePath, backupPath);
    }

    /**
     * ÌååÏùºÏùò import ÏàòÏ†ï
     */
    fixFileImports(filePath, issues) {
        if (issues.length === 0) return false;

        this.createBackup(filePath);
        
        let content = fs.readFileSync(filePath, 'utf8');
        let modified = false;

        // Îí§ÏóêÏÑúÎ∂ÄÌÑ∞ ÏàòÏ†ï (Ïù∏Îç±Ïä§ Î≥ÄÍ≤Ω Î∞©ÏßÄ)
        issues.sort((a, b) => b.index - a.index);

        issues.forEach(issue => {
            const oldImport = issue.fullMatch;
            const newImport = oldImport.replace(issue.path, issue.correctPath);
            
            content = content.slice(0, issue.index) + 
                     newImport + 
                     content.slice(issue.index + oldImport.length);
            
            modified = true;
            
            this.fixedImports.push({
                file: filePath,
                old: issue.path,
                new: issue.correctPath
            });
        });

        if (modified) {
            fs.writeFileSync(filePath, content);
        }

        return modified;
    }

    /**
     * Î™®Îì† ÌååÏùº Î∂ÑÏÑù Î∞è ÏàòÏ†ï
     */
    async fixAllImports() {
        console.log(chalk.blue('üîç Analyzing import statements...'));
        
        const sourceFiles = glob.sync(`${this.srcDir}/**/*.{js,vue,ts,jsx,tsx}`);
        let totalIssues = 0;
        let fixedFiles = 0;

        for (const filePath of sourceFiles) {
            try {
                const issues = this.analyzeFile(filePath);
                if (issues.length > 0) {
                    console.log(chalk.yellow(`‚ö†Ô∏è  ${filePath}: ${issues.length} broken imports`));
                    
                    if (this.fixFileImports(filePath, issues)) {
                        fixedFiles++;
                        console.log(chalk.green(`‚úÖ Fixed ${filePath}`));
                    }
                    
                    totalIssues += issues.length;
                    this.brokenImports.push(...issues);
                }
            } catch (error) {
                console.log(chalk.red(`‚ùå Error processing ${filePath}: ${error.message}`));
            }
        }

        return { totalIssues, fixedFiles };
    }

    /**
     * Í≤∞Í≥º Î¶¨Ìè¨Ìä∏ Ï∂úÎ†•
     */
    printReport(stats) {
        console.log('\n' + chalk.bold.blue('üìä Import Fix Report'));
        console.log(chalk.blue('‚îÄ'.repeat(50)));
        
        console.log(`${chalk.green('‚úÖ Fixed files:')} ${stats.fixedFiles}`);
        console.log(`${chalk.green('‚úÖ Fixed imports:')} ${this.fixedImports.length}`);
        console.log(`${chalk.yellow('‚ö†Ô∏è  Total issues found:')} ${stats.totalIssues}`);
        
        if (this.fixedImports.length > 0) {
            console.log('\n' + chalk.bold.green('üîß Fixed Imports:'));
            this.fixedImports.forEach(fix => {
                console.log(`  ${chalk.dim(fix.file)}`);
                console.log(`    ${chalk.red(fix.old)} ‚Üí ${chalk.green(fix.new)}`);
            });
        }

        if (this.backup) {
            console.log('\n' + chalk.blue('üíæ Backups created in .backup-imports/'));
            console.log(chalk.dim('Run "node scripts/restore-imports.js" to restore if needed'));
        }
    }

    /**
     * Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò
     */
    async run() {
        console.log(chalk.bold.blue('üöÄ Starting Import Fixer\n'));
        
        try {
            this.buildFileCache();
            const stats = await this.fixAllImports();
            this.printReport(stats);
            
            console.log('\n' + chalk.bold.green('üéâ Import fixing completed!'));
            
        } catch (error) {
            console.error(chalk.red('üí• Error:'), error.message);
            process.exit(1);
        }
    }
}

// CLI Ïã§Ìñâ
if (require.main === module) {
    const fixer = new ImportFixer({
        srcDir: 'src',
        backup: true,
        aliases: {
            '@': 'src',
            '@core': 'src/core',
            '@features': 'src/features',
            '@game': 'src/features/game',
            '@websocket': 'src/features/game/multiplayer/shared/services/websocket'
        }
    });
    
    fixer.run();
}

module.exports = ImportFixer; 